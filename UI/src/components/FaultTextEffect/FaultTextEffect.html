<!DOCTYPE html>
<!-- 定义HTML5文档 -->
<html lang="en">
<head>
    <!-- 设置字符编码为UTF-8 -->
    <meta charset="UTF-8">
    <!-- 确保页面在移动设备上自适应缩放 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 设置页面标题 -->
    <title>Fault Text Effect</title>
    <style>
        /* 基础样式设置 - 设置页面基本布局和背景 */
        body {
            margin: 0; /* 移除默认外边距 */
            padding: 0; /* 移除默认内边距 */
            display: flex; /* 使用Flex布局 */
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
            min-height: 100vh; /* 最小高度为视口高度 */
            background-color: #000; /* 设置背景色为黑色 */
            font-family: Arial, sans-serif; /* 设置字体 */
            overflow: hidden; /* 隐藏溢出内容 */
        }

        /* 父容器样式 - 用于包裹所有文本效果元素 */
        .glitch-wrapper {
            position: relative; /* 相对定位，便于子元素绝对定位 */
            width: 100%; /* 宽度占满父容器 */
            height: 100%; /* 高度占满父容器 */
            cursor: pointer; /* 鼠标悬停时显示指针 */
        }

        /* 文本容器样式 - 用于控制文本的定位和裁剪效果 */
        .text-container {
            position: absolute; /* 绝对定位，脱离文档流 */
            user-select: none; /* 防止文本被选中 */
            /* 初始裁剪路径，显示完整文本 - 使用多边形定义可见区域 */
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); /* 默认显示全部内容 */
            transform: translate(-50%, -50%); /* 水平垂直居中 */
            top: 50%; /* 顶部定位到50% */
            left: 50%; /* 左侧定位到50% */
        }

        /* 原始文本样式 - 基础文本显示 */
        .original-text {
            font-size: 48px; /* 设置字体大小 */
            font-weight: bold; /* 设置字体加粗 */
            color: white; /* 设置字体颜色为白色 */
            text-transform: uppercase; /* 转换为大写 */
            position: relative; /* 相对定位 */
            z-index: 1; /* 设置层级，确保在通道下方 */
        }

        /* 通道文本样式 - 用于创建RGB分离效果的基础样式 */
        .channel {
            position: absolute; /* 绝对定位，与原始文本重叠 */
            top: 0; /* 顶部对齐 */
            left: 0; /* 左侧对齐 */
            font-size: 48px; /* 与原始文本相同的字体大小 */
            font-weight: bold; /* 设置字体加粗 */
            text-transform: uppercase; /* 转换为大写 */
            mix-blend-mode: screen; /* 使用屏幕混合模式创建发光效果 */
            opacity: 0; /* 默认不可见 */
            transition: opacity 0.2s ease; /* 透明度过渡动画 */
            z-index: 2; /* 设置层级，高于原始文本 */
        }

        /* 红色通道文本样式 - 用于创建RGB分离效果中的红色通道 */
        .red-channel { 
            color: #FF0000; /* 设置红色 */
        }

        /* 蓝色通道文本样式 - 用于创建RGB分离效果中的蓝色通道 */
        .blue-channel { 
            color: #0000FF; /* 设置蓝色 */
        }

        /* 激活状态下的通道显示 - 控制RGB通道的可见性 */
        .active .channel { 
            opacity: 1; /* 激活时显示通道 */
        }
    </style>
</head>
<body>
    <!-- 主容器，用于触发故障效果 -->
    <div class="glitch-wrapper">
        <!-- 文本容器，包含原始文本 -->
        <div class="text-container">
            <!-- 原始文本内容 -->
            <div class="original-text">Click Me</div>
        </div>
    </div>

    <script>
        // 获取DOM元素引用
        const glitchWrapper = document.querySelector('.glitch-wrapper'); // 获取主容器
        const originalContainer = document.querySelector('.text-container'); // 获取原始文本容器
        
        // 复制容器函数 - 创建多个文本容器以实现更丰富的故障效果
        function duplicateContainers() {
            // 创建容器数量 - 控制故障效果的复杂程度
            const containerCount = 3; // 设置复制的容器数量
            
            // 为每个容器创建新实例 - 复制原始容器以创建多层效果
            for (let i = 1; i < containerCount; i++) {
                const newContainer = originalContainer.cloneNode(true); // 深拷贝原始容器
                newContainer.style.transform = 'translate(-50%, -50%)'; // 设置居中定位
                glitchWrapper.appendChild(newContainer); // 添加到主容器
            }
        }
        
        // 执行容器复制 - 初始化多层文本效果
        duplicateContainers();
        
        // 获取所有文本容器 - 用于后续效果控制
        const textContainers = document.querySelectorAll('.text-container'); // 获取所有文本容器
        
        // 为每个容器创建颜色通道元素 - 设置RGB分离效果
        textContainers.forEach(textContainer => {
            const originalText = textContainer.querySelector('.original-text'); // 获取原始文本元素
            
            // 创建颜色通道元素 - 设置RGB分离效果的基础结构
            function setupGlitchEffect() {
                const text = originalText.textContent; // 获取原始文本内容
                
                // 创建红色通道 - 用于实现RGB分离效果中的红色部分
                const redChannel = document.createElement('div'); // 创建红色通道元素
                redChannel.className = 'channel red-channel'; // 设置类名
                redChannel.textContent = text; // 设置文本内容
                textContainer.appendChild(redChannel); // 添加到容器
                
                // 创建蓝色通道 - 用于实现RGB分离效果中的蓝色部分
                const blueChannel = document.createElement('div'); // 创建蓝色通道元素
                blueChannel.className = 'channel blue-channel'; // 设置类名
                blueChannel.textContent = text; // 设置文本内容
                textContainer.appendChild(blueChannel); // 添加到容器
                
                return { redChannel, blueChannel }; // 返回通道元素引用
            }
            
            const { redChannel, blueChannel } = setupGlitchEffect(); // 执行设置并获取通道
            
            // 将startGlitchEffect函数和所需引用附加到容器上 - 为每个容器添加独立的效果控制
            textContainer.glitchElements = { redChannel, blueChannel }; // 存储通道元素
            textContainer.timers = []; // 初始化计时器数组
            textContainer.startGlitchEffect = function() {
                startGlitchEffect(this, this.glitchElements, this.timers); // 绑定故障效果函数
            };
        });
        
        // 动画状态控制 - 全局状态，防止重复触发效果
        let animationActive = false; // 动画是否正在进行
        
        // 获取随机整数 - 用于生成各种随机效果参数
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min; // 返回指定范围内的随机整数
        }
        
        // 开始故障效果 - 实现主要的故障动画效果
        function startGlitchEffect(container, elements, timers) {
            const { redChannel, blueChannel } = elements; // 获取颜色通道元素
            
            container.classList.add('active'); // 激活容器，显示颜色通道
            
            // 颜色分离效果 - 控制RGB通道的偏移
            function updateColorSeparation() {
                const redOffsetX = getRandomInt(-5, 5); // 随机X轴偏移
                const redOffsetY = getRandomInt(-5, 5); // 随机Y轴偏移
                const blueOffsetX = getRandomInt(-5, 5); // 随机X轴偏移
                const blueOffsetY = getRandomInt(-5, 5); // 随机Y轴偏移
                
                redChannel.style.transform = `translate(${redOffsetX}%, ${redOffsetY}%)`; // 应用红色通道偏移
                blueChannel.style.transform = `translate(${blueOffsetX}%, ${blueOffsetY}%)`; // 应用蓝色通道偏移
            }
            
            // 抖动效果 - 创建整体文本的随机抖动
            function updateJitter() {
                const jitterX = getRandomInt(-30, 30); // 随机X轴抖动
                const jitterY = getRandomInt(-30, 30); // 随机Y轴抖动
                const baseTransform = 'translate(-50%, -50%)'; // 基础居中变换
                
                container.style.transform = `${baseTransform} translate(${jitterX}%, ${jitterY}%)`; // 应用抖动效果
                
                // 随机触发颜色分离效果，增加视觉变化
                if (Math.random() > 0.7) { // 30%的概率触发颜色分离
                    updateColorSeparation();
                }
            }
            
            // 裁剪效果 - 创建文本的随机裁剪区域
            function updateClipPath() {
                const blockWidth = getRandomInt(10, 40); // 随机裁剪块宽度
                const blockHeight = getRandomInt(10, 40); // 随机裁剪块高度
                const blockX = getRandomInt(0, 40); // 随机X轴起始位置
                const blockY = getRandomInt(0, 40); // 随机Y轴起始位置
                
                // 定义裁剪路径，形成矩形裁剪区域
                const clipPath = `polygon(
                    ${blockX}% ${blockY}%,
                    calc(${blockX}% + ${blockWidth}%) ${blockY}%,
                    calc(${blockX}% + ${blockWidth}%) calc(${blockY}% + ${blockHeight}%),
                    ${blockX}% calc(${blockY}% + ${blockHeight}%)
                )`;
                
                container.style.clipPath = clipPath; // 应用裁剪效果
            }
            
            // 初始效果 - 启动时立即应用颜色分离
            updateColorSeparation();
            
            // 设置定时器 - 控制各种效果的更新频率
            const jitterTimer = setInterval(updateJitter, 50); // 每50ms更新抖动效果
            const clipTimer = setInterval(updateClipPath, 100); // 每100ms更新裁剪效果
            
            timers.push(jitterTimer, clipTimer); // 存储计时器
            
            // 重置效果 - 2秒后停止所有效果
            setTimeout(() => {
                stopGlitchEffect(container, elements, timers); // 调用停止函数
            }, 2000); // 持续2秒
        }
        
        // 停止故障效果 - 清理所有动画效果和状态
        function stopGlitchEffect(container, elements, timers) {
            const { redChannel, blueChannel } = elements; // 获取颜色通道元素
            
            container.classList.remove('active'); // 移除激活状态
            
            // 清除所有计时器 - 停止所有动画效果
            timers.forEach(timer => clearInterval(timer)); // 清除所有定时器
            container.timers = []; // 重置计时器数组
            
            // 重置所有变换 - 恢复原始状态
            redChannel.style.transform = 'translate(0%, 0%)'; // 重置红色通道位置
            blueChannel.style.transform = 'translate(0%, 0%)'; // 重置蓝色通道位置
            container.style.transform = 'translate(-50%, -50%)'; // 重置容器位置
            container.style.clipPath = 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)'; // 重置裁剪路径
        }
        
        // 点击事件监听 - 触发故障效果
        glitchWrapper.addEventListener('click', () => {
            if (animationActive) return; // 防止重复触发
            
            animationActive = true; // 设置动画进行中
            
            // 为所有容器启动效果 - 创建多层故障效果
            textContainers.forEach(container => {
                container.startGlitchEffect(); // 触发每个容器的故障效果
            });
            
            // 2秒后重置全局状态 - 允许再次触发效果
            setTimeout(() => {
                animationActive = false; // 重置动画状态
            }, 2000); // 持续2秒
        });
    </script>
</body>
</html>