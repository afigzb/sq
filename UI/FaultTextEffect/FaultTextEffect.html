<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fault Text Effect</title>
    <style>
        /* 基础样式设置 */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        /* 父容器样式 */
        .glitch-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* 文本容器样式 */
        .text-container {
            position: absolute;
            user-select: none;
            /* 初始裁剪路径，显示完整文本 */
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            transform: translate(-50%, -50%);
            top: 50%;
            left: 50%;
        }

        /* 原始文本样式 */
        .original-text {
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            position: relative;
            z-index: 1;
        }

        /* 通道文本样式 */
        .channel {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 48px;
            font-weight: bold;
            text-transform: uppercase;
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 2;
        }

        /* 红色通道文本样式 */
        .red-channel { color: #FF0000; }
        /* 蓝色通道文本样式 */
        .blue-channel { color: #0000FF; }

        /* 激活状态下的通道显示 */
        .active .channel { opacity: 1; }
    </style>
</head>
<body>
    <div class="glitch-wrapper">
        <div class="text-container">
            <div class="original-text">Click Me</div>
        </div>
    </div>

    <script>
        const glitchWrapper = document.querySelector('.glitch-wrapper');
        const originalContainer = document.querySelector('.text-container');
        
        // 复制容器函数
        function duplicateContainers() {
            // 创建容器数量
            const containerCount = 3;
            
            // 为每个容器创建新实例
            for (let i = 1; i < containerCount; i++) {
                const newContainer = originalContainer.cloneNode(true);
                newContainer.style.transform = 'translate(-50%, -50%)';
                glitchWrapper.appendChild(newContainer);
            }
        }
        
        // 执行容器复制
        duplicateContainers();
        
        // 获取所有文本容器
        const textContainers = document.querySelectorAll('.text-container');
        
        // 为每个容器创建颜色通道元素
        textContainers.forEach(textContainer => {
            const originalText = textContainer.querySelector('.original-text');
            
            // 创建颜色通道元素
            function setupGlitchEffect() {
                const text = originalText.textContent;
                
                // 创建红色通道
                const redChannel = document.createElement('div');
                redChannel.className = 'channel red-channel';
                redChannel.textContent = text;
                textContainer.appendChild(redChannel);
                
                // 创建蓝色通道
                const blueChannel = document.createElement('div');
                blueChannel.className = 'channel blue-channel';
                blueChannel.textContent = text;
                textContainer.appendChild(blueChannel);
                
                return { redChannel, blueChannel };
            }
            
            const { redChannel, blueChannel } = setupGlitchEffect();
            
            // 将startGlitchEffect函数和所需引用附加到容器上
            textContainer.glitchElements = { redChannel, blueChannel };
            textContainer.timers = [];
            textContainer.startGlitchEffect = function() {
                startGlitchEffect(this, this.glitchElements, this.timers);
            };
        });
        
        // 动画状态控制 - 全局状态
        let animationActive = false;
        
        // 获取随机整数
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // 开始故障效果
        function startGlitchEffect(container, elements, timers) {
            const { redChannel, blueChannel } = elements;
            
            container.classList.add('active');
            
            // 颜色分离效果
            function updateColorSeparation() {
                const redOffsetX = getRandomInt(-5, 5);
                const redOffsetY = getRandomInt(-5, 5);
                const blueOffsetX = getRandomInt(-5, 5);
                const blueOffsetY = getRandomInt(-5, 5);
                
                redChannel.style.transform = `translate(${redOffsetX}%, ${redOffsetY}%)`;
                blueChannel.style.transform = `translate(${blueOffsetX}%, ${blueOffsetY}%)`;
            }
            
            // 抖动效果
            function updateJitter() {
                const jitterX = getRandomInt(-30, 30);
                const jitterY = getRandomInt(-30, 30);
                const baseTransform = 'translate(-50%, -50%)';
                
                container.style.transform = `${baseTransform} translate(${jitterX}%, ${jitterY}%)`;
                
                if (Math.random() > 0.7) {
                    updateColorSeparation();
                }
            }
            
            // 裁剪效果
            function updateClipPath() {
                const blockWidth = getRandomInt(10, 40);
                const blockHeight = getRandomInt(10, 40);
                const blockX = getRandomInt(0, 40);
                const blockY = getRandomInt(0, 40);
                
                const clipPath = `polygon(
                    ${blockX}% ${blockY}%,
                    calc(${blockX}% + ${blockWidth}%) ${blockY}%,
                    calc(${blockX}% + ${blockWidth}%) calc(${blockY}% + ${blockHeight}%),
                    ${blockX}% calc(${blockY}% + ${blockHeight}%)
                )`;
                
                container.style.clipPath = clipPath;
            }
            
            // 初始效果
            updateColorSeparation();
            
            // 设置定时器
            const jitterTimer = setInterval(updateJitter, 50);
            const clipTimer = setInterval(updateClipPath, 100);
            
            timers.push(jitterTimer, clipTimer);
            
            // 重置效果
            setTimeout(() => {
                stopGlitchEffect(container, elements, timers);
            }, 2000);
        }
        
        // 停止故障效果
        function stopGlitchEffect(container, elements, timers) {
            const { redChannel, blueChannel } = elements;
            
            container.classList.remove('active');
            
            // 清除所有计时器
            timers.forEach(timer => clearInterval(timer));
            container.timers = [];
            
            // 重置所有变换
            redChannel.style.transform = 'translate(0%, 0%)';
            blueChannel.style.transform = 'translate(0%, 0%)';
            container.style.transform = 'translate(-50%, -50%)';
            container.style.clipPath = 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)';
        }
        
        // 点击事件监听
        glitchWrapper.addEventListener('click', () => {
            if (animationActive) return;
            
            animationActive = true;
            
            // 为所有容器启动效果
            textContainers.forEach(container => {
                container.startGlitchEffect();
            });
            
            // 2秒后重置全局状态
            setTimeout(() => {
                animationActive = false;
            }, 2000);
        });
    </script>
</body>
</html>
