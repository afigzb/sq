<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自动滚动</title>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body x-data="
{
    originalData: [
        { 
            title: '行业动态：最新技术突破', 
            content: '人工智能领域取得重大进展，自然语言处理模型性能提升...',
            time: '5分钟前'
        },
        { 
            title: '行业动态：最新技术突破', 
            content: '人工智能领域取得重大进展，自然语言处理模型性能提升...',
            time: '4分钟前'
        },
        { 
            title: '行业动态：最新技术突破', 
            content: '人工智能领域取得重大进展，自然语言处理模型性能提升...',
            time: '3分钟前'
        },
        { 
            title: '行业动态：最新技术突破', 
            content: '人工智能领域取得重大进展，自然语言处理模型性能提升...',
            time: '2分钟前'
        },
        { 
            title: '行业动态：最新技术突破', 
            content: '人工智能领域取得重大进展，自然语言处理模型性能提升...',
            time: '1分钟前'
        }
    ],
    addNewItem() {
        this.originalData.unshift({
            title: '新动态：重大更新',
            content: '刚刚发布的最新消息...',
            time: '刚刚'
        });
    }
}
">
<div class="max-w-md mx-auto my-8 p-6 bg-gray-50 rounded-2xl shadow-xl">
    <h2 class="text-2xl font-bold text-gray-800 mb-6">实时资讯播报</h2>
    <button @click="addNewItem" class="mb-4 px-4 py-2 bg-blue-500 text-white rounded">添加新项</button>
    <div x-data="verticalInfiniteScroll({ 
        originalData,
        scrollSpeed: 0.15
    })"
    x-ref="container"
    x-effect="updateDataVerticalInfiniteScroll(originalData)"
    class="relative h-96 overflow-hidden rounded-xl bg-white shadow-inner"
    @mouseenter.passive="pauseAutoScroll" 
    @mouseleave.passive="resumeAutoScroll"
    @wheel.prevent="handleWheel">
        <div class="absolute inset-0" 
            :style="`transform: translateY(${virtualPosition}px)`"
            @mousedown.prevent="startDrag($event)"
            @touchstart.passive="startDrag($event)">
            <template x-for="(item, index) in mirroredData" :key="index">
                <div class="group px-4 py-6 hover:bg-gray-50 transition-colors scroll-item 
                        border-b border-gray-100 last:border-0">
                    <div class="flex items-start">
                        <div class="flex-shrink-0 w-8 h-8 bg-gradient-to-br from-blue-400 to-purple-500 
                                rounded-lg flex items-center justify-center text-white 
                                text-sm font-bold">
                            <span x-text="index % originalData.length + 1"></span>
                        </div>
                        
                        <div class="ml-4 flex-1">
                            <h3 class="font-semibold text-gray-800 line-clamp-1" 
                                x-text="item.title"></h3>
                            <p class="text-sm text-gray-600 mt-1 line-clamp-2" 
                            x-text="item.content"></p>
                            <div class="flex items-center mt-2 text-xs text-gray-400">
                                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span x-text="item.time"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </div>
</div>
    
<script>
function verticalInfiniteScroll(config = {}) {
  // 配置参数解构
  const { 
      originalData = [],
      scrollSpeed: originalSpeed = 0.15,
      itemHeight = null
  } = config;

  return {
      // 状态初始化
      originalData,
      originalSpeed,
      itemHeight,
      containerHeight: 0,
      shouldScroll: false,
      mirroredData: [],
      virtualPosition: 0,
      targetPosition: 0,
      isDragging: false,
      lastDragY: 0,

      visibleItems: [],
      totalHeight: 0,
      
      // 主初始化流程
      async updateDataVerticalInfiniteScroll(newData) {
        console.log('Updating data:', newData);
        this.originalData = newData;
        this.virtualPosition = 0;
        this.targetPosition = 0;
        await this.initVerticalInfiniteScroll();
        this.visibleItems = this.getVisibleItems();
    },

      async initVerticalInfiniteScroll() {
          if (!this.originalData || this.originalData.length === 0) {
            this.setupScrollData();

              console.log('No data available for scrolling.');
              return;
          }
          console.log('originalData:', this.originalData);
          await this.initializeContainer();
          await this.measureItemHeight();
          this.determineScrollBehavior();
          this.setupScrollData();
          this.shouldScroll && this.autoScroll();
          this.shouldScroll && this.setupWheelListener();
      },

      /* ========== 核心逻辑模块 ========== */
      // 容器初始化
      async initializeContainer() {
          this.containerHeight = this.$refs.container.offsetHeight;
      },

      getVisibleItems() {
          if (!this.itemHeight) return [];
          
          const startIdx = Math.floor(-this.virtualPosition / this.itemHeight);
          const visibleCount = Math.ceil(this.containerHeight / this.itemHeight) + 2;
          const endIdx = startIdx + visibleCount;
          
          return Array.from({ length: endIdx - startIdx }, (_, i) => ({
              ...this.originalData[(startIdx + i) % this.originalData.length],
              index: startIdx + i
          }));
      },

        // 动态测量元素高度
        async measureItemHeight() {
            if (this.itemHeight !== null) return;
            
            this.mirroredData = [...this.originalData];
            await this.$nextTick();
            
            const element = this.$el.querySelector('.scroll-item');
            this.itemHeight = element?.offsetHeight || 0;
        },

        // 判断是否需要滚动
        determineScrollBehavior() {
            this.totalHeight = this.originalData.length * this.itemHeight;
            this.shouldScroll = this.totalHeight > this.containerHeight;
        },

        // 数据初始化
        setupScrollData() {
            const repeatCount = 3;
            this.mirroredData = this.shouldScroll 
                ? (this.originalData.length < 20 
                    ? Array(repeatCount).fill([...this.originalData]).flat()
                    : [...this.originalData])
                : [...this.originalData];
            this.scrollSpeed = this.shouldScroll ? this.originalSpeed : 0;
        },
      /* ========== 滚动控制模块 ========== */
      autoScroll() {
        if (this.isAnimating) return; // 防止重复启动
        this.isAnimating = true;
        const animate = () => {
            if (!this.shouldScroll) {
                this.isAnimating = false;
                return;
            }
            
            this.updateScrollPosition();
            this.applySmoothScrolling();
            requestAnimationFrame(animate.bind(this));
        };
        animate();
    },

      updateScrollPosition() {
          if (!this.isDragging) {
              this.targetPosition -= this.scrollSpeed;
              this.checkBoundary();
          }
      },

      applySmoothScrolling() {
          this.virtualPosition += (this.targetPosition - this.virtualPosition) * 0.1;
      },

      checkBoundary() {
          if (!this.shouldScroll) return;
          
          // 优化后的边界检测
          const maxScroll = -this.totalHeight;
          if (this.targetPosition <= maxScroll) {
              this.targetPosition += this.totalHeight;
              this.virtualPosition += this.totalHeight;
          }
          else if (this.targetPosition > 0) {
              this.targetPosition -= this.totalHeight;
              this.virtualPosition -= this.totalHeight;
          }
      },

      adjustScrollPosition() {
          const adjustment = this.originalData.length * this.itemHeight;
          // 根据方向判断调整量符号
          const direction = this.targetPosition < 0 ? 1 : -1;
          this.targetPosition += adjustment * direction;
          this.virtualPosition += adjustment * direction;
      },

      /* ========== 拖拽事件模块 ========== */
      startDrag(e) {
          if (!this.shouldScroll) return;
          
          this.isDragging = true;
          this.lastDragY = this.getClientY(e);
          this.bindDragEvents();
      },

      handleDrag(e) {
          if (!this.isDragging) return;
          
          e.preventDefault();
          const deltaY = this.calculateDeltaY(e);
          this.updateDragPosition(deltaY);
      },

      endDrag() {
          this.isDragging = false;
          this.unbindDragEvents();
      },

      // 事件辅助方法
      getClientY(e) {
          return e.clientY || e.touches[0].clientY;
      },

      calculateDeltaY(e) {
          const currentY = this.getClientY(e);
          const delta = currentY - this.lastDragY;
          this.lastDragY = currentY;
          return delta;
      },

      updateDragPosition(deltaY) {
          this.targetPosition += deltaY;
      },

      /* ========== 事件管理模块 ========== */
      bindDragEvents() {
          const events = [
              ['mousemove', this.handleDrag],
              ['mouseup', this.endDrag],
              ['touchmove', this.handleDrag],
              ['touchend', this.endDrag]
          ];
          
          events.forEach(([event, handler]) => {
              document.addEventListener(event, handler.bind(this), { passive: false });
          });
      },

      unbindDragEvents() {
          const events = ['mousemove', 'mouseup', 'touchmove', 'touchend'];
          events.forEach(event => {
              document.removeEventListener(event, this.handleDrag);
              document.removeEventListener(event, this.endDrag);
          });
      },

      setupWheelListener() {
        this.$refs.container.removeEventListener('wheel', this.handleWheel.bind(this));
        this.$refs.container.addEventListener('wheel', this.handleWheel.bind(this), { 
            passive: false 
        });
    },
      /* ========== 滚轮事件处理 ========== */
      handleWheel(e) {
          if (!this.shouldScroll) return;

          e.preventDefault();
          const scrollMultiplier = 0.1; // 滚动速度系数

          // 同时支持触控板滑动和传统滚轮
          const deltaY = e.deltaY || e.wheelDeltaY * -1;
          const deltaMode = e.deltaMode; // 0: 像素 1: 行 2: 页

          let scrollAmount = deltaY;
          if (deltaMode === 1) scrollAmount *= 24; // 行模式转换
          if (deltaMode === 2) scrollAmount *= 100; // 页模式转换

          // 调整滚动方向，确保 deltaY 正确表示向下滚动，负值表示向上滚动
          this.applyWheelScroll(-scrollAmount * scrollMultiplier);
      },

      applyWheelScroll(delta) {
          // 在自动滚动时暂停并接管
          if (this.scrollSpeed > 0) {
              this.pauseAutoScroll();
              this.resumeAfterInteraction();
          }

          // 自然滚动方向调整
          this.targetPosition += delta;
          this.checkBoundary(); // 检查边界条件
          this.smoothScrolling();
      },

      smoothScrolling() {
          // 增加惯性滚动效果
          this.virtualPosition += (this.targetPosition - this.virtualPosition) * 0.2;
      },

      resumeAfterInteraction() {
        clearTimeout(this.resumeTimer);
        console.log('Clearing previous timer:', this.resumeTimer);
        this.resumeTimer = setTimeout(() => {
            console.log('Resuming auto scroll');
            if (!this.isDragging) this.resumeAutoScroll();
        }, 3000);
    },

      /* ========== 滚动控制接口 ========== */
      pauseAutoScroll() {
          this.scrollSpeed = 0;
      },

      resumeAutoScroll() {
          this.scrollSpeed = this.originalSpeed;
      }
  };
}
</script>
</body>
</html>
