<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PullToRefresh</title>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.12.0/dist/cdn.min.js" defer></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-100">
  <div x-data="dropdownRefresh()" class="relative overflow-hidden">
    <!-- 刷新容器 -->
    <div x-show="isRefreshing" x-transition
      class="w-full bg-blue-500 text-white text-center transition-all ease-out duration-400 bg-[url('./img/tsl1.webp')] bg-bottom"
      :style="`height: ${refreshHeight}px`">
      <div x-show="refreshHeight >= threshold" class="py-2">正在刷新...</div>
    </div>

    <!-- 正文容器 -->
    <div class="h-screen" @touchstart="startDrag($event)" @touchmove="dragging($event)" @touchend="endDrag"
      @touchcancel="endDrag">
      <div class="bg-gray-200 p-4 rounded-md shadow-md">
        <p>这是正文内容部分。你可以根据自己的需求填充内容，模拟实际页面。</p>
        <p>更多内容...</p>
      </div>
    </div>
    <div class="h-screen w-full bg-red-500">

    </div>
  </div>

  <script>
    function dropdownRefresh() {
      return {
        refreshHeight: 0,          // 刷新容器的高度
        isRefreshing: false,       // 是否正在刷新
        startTouchY: 0,            // 手指触摸位置
        threshold: 100,            // 触发刷新的高度阈值
        maxHeight: 1500,           // 最大容器高度
        dampingFactor: 0.4,        // 初始阻尼系数
        lastY: 0,                  // 上一次触摸的 Y 坐标
        deltaY: 0,                 // 当前的增量
        isAtTop: false,            // 是否在顶部
        accumulatedIncrement: 0,   // 累积增量
        updateThreshold: 1,       // 更新阈值，减少DOM更新的频率
        // 开始拖动
        startDrag(event) {
          this.startTouchY = event.touches[0].clientY;
          this.lastY = this.startTouchY;
          this.deltaY = 0;
          this.isRefreshing = false;
          this.isAtTop = this.isPageAtTop(); // 判断当前页面是否在顶部
        },

        // 处理拖动
        dragging(event) {
          // 只有在顶部才可下拉
          if (!this.isAtTop) return;

          let currentY = event.touches[0].clientY;
          let deltaY = currentY - this.lastY;

          // 动态阻尼系数和速度阻尼
          let dynamicDampingFactor = Math.max(0.1, this.dampingFactor * (1 - this.refreshHeight / 300));
          let increment = deltaY * dynamicDampingFactor;

          this.accumulatedIncrement += increment;

          // 只在拖动超过阈值时更新 UI
          if (Math.abs(this.accumulatedIncrement) >= this.updateThreshold) {
            requestAnimationFrame(() => {
              this.deltaY = Math.min(this.deltaY + this.accumulatedIncrement, this.maxHeight);
              this.refreshHeight = Math.min(this.deltaY, this.maxHeight);
              this.accumulatedIncrement = 0;
            });
          }

          this.lastY = currentY;

          // 如果在顶部且刷新高度为0，重新开始拖动
          if (this.refreshHeight <= 0) {
            this.startDrag(event);
          }

          // 拖动时防止页面滚动
          this.preventPageScroll(event);
        },


        // 拖动结束
        endDrag() {
          if (this.refreshHeight >= this.threshold) {
            this.startRefresh();
          } else {
            this.refreshHeight = 0;
          }
        },

        // 拖动结束运行逻辑，自行更改
        startRefresh() {
          this.isRefreshing = true;
          setTimeout(() => {
            this.isRefreshing = false;
            this.refreshHeight = 0;
          }, 2000); // 模拟2秒刷新时间
        },

        // 防止页面滚动
        preventPageScroll(event) {
          if (this.refreshHeight > 0 && !event.defaultPrevented) {
            event.preventDefault();
          }
        },

        // 判断页面是否在顶部
        isPageAtTop() {
          return document.documentElement.scrollTop === 0;
        },
      };
    }
  </script>


</body>

</html>